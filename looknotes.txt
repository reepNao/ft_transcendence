from channels.generic.websocket import AsyncWebsocketConsumer
import json
import asyncio
import requests
import aiohttp
import logging

class PongGame:
    def __init__(self, canvas_width=960, canvas_height=480):
        self.canvas_width = canvas_width
        self.canvas_height = canvas_height
        self.padd_left = self.create_paddle(60)
        self.padd_right = self.create_paddle(canvas_width - 100)
        self.ball = self.create_ball()
        self.game_status = 0
        self.user_count = 0
        self.players = {'left': None, 'right': None}

    def create_paddle(self, x):
        return {
            'speed': 35,
            'positionX': x,
            'positionY': self.canvas_height / 2 - 100,
            'sizeX': 24,
            'sizeY': 160,
            'score': 0
        }

    def create_ball(self):
        return {
            'speedX': 10,
            'speedY': 10,
            'positionX': self.canvas_width / 2,
            'positionY': self.canvas_height / 2,
            'size': 20,
            'dir': True
        }

    def reset_ball(self):
        self.ball['positionX'] = self.canvas_width / 2
        self.ball['positionY'] = self.canvas_height / 2
        self.ball['speedX'] = 10 if self.ball['speedX'] > 0 else -10
        self.ball['speedY'] = -10 if self.ball['dir'] else 10
        self.ball['dir'] = not self.ball['dir']

    def update_ball(self):
        self.ball['positionX'] += self.ball['speedX']
        self.ball['positionY'] += self.ball['speedY']

    def check_collisions(self):
        self.check_wall_collision()
        self.check_paddle_collision()

    def check_wall_collision(self):
        if self.ball['positionX'] + self.ball['size'] >= self.canvas_width or self.ball['positionX'] - self.ball['size'] <= 0:
            self.update_score()
            self.reset_ball()
        if self.ball['positionY'] + self.ball['size'] >= self.canvas_height or self.ball['positionY'] - self.ball['size'] <= 0:
            self.ball['speedY'] *= -1

    def check_paddle_collision(self):
        for paddle in [self.padd_left, self.padd_right]:
            if (abs(self.ball['positionX'] - (paddle['positionX'] + paddle['sizeX']/2)) <= self.ball['size'] + paddle['sizeX']/2 and
                    abs(self.ball['positionY'] - (paddle['positionY'] + paddle['sizeY']/2)) <= self.ball['size'] + paddle['sizeY']/2):
                self.ball['speedX'] *= -1

    def update_score(self):
        if self.ball['speedX'] > 0:
            self.padd_right['score'] += 1
        else:
            self.padd_left['score'] += 1

    def move_paddle(self, player, direction):
        paddle = self.padd_left if player == 'left' else self.padd_right
        paddle['positionY'] += paddle['speed'] * direction
        paddle['positionY'] = max(0, min(self.canvas_height - paddle['sizeY'], paddle['positionY']))

    def is_game_over(self):
        return self.padd_left['score'] == 5 or self.padd_right['score'] == 5

    def get_winner(self):
        winner = 'left' if self.padd_left['score'] == 5 else 'right'
        winner_username = self.players[winner]
        return winner

    def add_player(self, username):
        if not self.players['left']:
            self.players['left'] = username
            return 'left'
        elif not self.players['right']:
            self.players['right'] = username
            return 'right'
        return None

    def is_full(self):
        return self.players['left'] and self.players['right']


class Pong(AsyncWebsocketConsumer):
    games = {}
    API_URLS = {
        'get_user': "http://apigateway:8000/user/get/id",
        'check_game': "http://apigateway:8000/game/check",
        'update_game': "http://gameservice:8010/game/update"
    }

    async def connect(self):
        self.room_id, self.access_token = self.parse_query_string()
        self.username = await self.get_username()

        if not self.username or not await self.check_game():
            await self.close()
            return

        await self.accept()
        await self.join_game()

    async def disconnect(self, close_code):
        if self.room_id in self.games:
            game = self.games[self.room_id]
            game.game_status = 0
            game.user_count -= 1
            if game.user_count <= 0:
                await self.update_game_status(3, 0, 0)
                del self.games[self.room_id]
            else:
                await self.group_send('disconnect_message', {'disconnected_user': self.username})

    async def receive(self, text_data):
        game = self.games.get(self.room_id)
        if not game or game.game_status != 1:
            return

        direction = -1 if text_data == 'w' else 1 if text_data == 's' else 0
        if direction != 0:
            game.move_paddle(self.player_side, direction)

    async def game_loop(self):
        game = self.games[self.room_id]
        while game.game_status:
            game.update_ball()
            game.check_collisions()
            await self.group_send('pong_message', {'message': 'game_run'})

            if game.is_game_over():
                await self.handle_game_over()
                break

            await asyncio.sleep(0.025)

    async def handle_game_over(self):
        game = self.games[self.room_id]
        winner = game.get_winner()
        new_game_id = await self.update_game_status(2, game.padd_right['score'], game.padd_left['score'])
        logging.error("winner: %s new_game_id: %s", winner, new_game_id)
        await self.group_send('pong_message', {
            'message': 'game_over',
            'winner': winner,
            'newGame': new_game_id
        })

    async def join_game(self):
        if self.room_id not in self.games:
            self.games[self.room_id] = PongGame()

        game = self.games[self.room_id]
        player_side = game.add_player(self.username)

        if player_side is None:
            await self.close()
            return

        self.player_side = player_side
        await self.channel_layer.group_add(self.room_id, self.channel_name)
        game.user_count += 1

        if game.is_full():
            await self.start_game()

    async def start_game(self):
        game = self.games[self.room_id]
        game.game_status = 1
        game.user_count = 2
        asyncio.create_task(self.game_loop())

    async def pong_message(self, event):
        if event['message'] == 'game_over':
            if self.username == event['winner']:
                await self.send(text_data=json.dumps({
                    'message': 'game_over',
                    'winner': event['winner'],
                    'newGame': event['newGame']
                }))
            else:
                await self.send(text_data=json.dumps({
                    'message': 'game_over',
                    'winner': event['winner'],
                    'newGame': "",
                }))
            await self.close()
            return

        game = self.games[self.room_id]
        await self.send(text_data=json.dumps({
            'message': event['message'],
            'padd_left': game.padd_left,
            'padd_right': game.padd_right,
            'ball': game.ball,
            'padd_left_username': game.players['left'],
            'padd_right_username': game.players['right'],
            'padd_left_score': game.padd_left['score'],
            'padd_right_score': game.padd_right['score']
        }))

    async def disconnect_message(self, event):
        game = self.games[self.room_id]
        disconnected_user = event['disconnected_user']
        winner = game.padd_left['username'] if game.padd_left['username'] != disconnected_user else game.padd_right['username']
        await self.send(text_data=json.dumps({
            'message': 'game_over',
            'winner': winner
        }))
        await self.close()

    async def group_send(self, message_type, message):
        await self.channel_layer.group_send(self.room_id, {
            'type': message_type,
            **message
        })

    def parse_query_string(self):
        query_params = self.scope['query_string'].decode('utf-8').split('?')
        room_id = query_params[0].split('=')[1]
        access_token = query_params[1].split('=')[1]
        logging.error("room_id: %s access_token: %s", room_id, access_token)
        return room_id, access_token

    async def get_username(self):
        try:
            response = await self.make_request('get', self.API_URLS['get_user'])
            logging.error("response: %s", response)

            return response['data']['data'][0]['username'] if response['status_code'] == 200 else None
        except Exception as e:
            logging.error(f"Error getting username: {str(e)}")
            return None

    async def check_game(self):
        try:
            response = await self.make_request('get', f"{self.API_URLS['check_game']}?game_id={self.room_id}")
            return response['status_code'] == 200
        except Exception as e:
            logging.error(f"Error checking game: {str(e)}")
            return False

    async def update_game_status(self, status, player1_score, player2_score):
        try:
            body = {
                'game_id': int(self.room_id),
                'status': status,
                'player1_score': player1_score,
                'player2_score': player2_score,
            }
            response = await self.make_request('put', self.API_URLS['update_game'], json.dumps(body))
            if response['status_code'] == 200 and 'data' in response and 'game_id' in response['data']:
                return response['data']['game_id']
            return None
        except Exception as e:
            logging.error(f"Error updating game status: {str(e)}")
            return None

    async def make_request(self, method, url, data=None):
        logging.error("access_token: %s method: %s url: %s data: %s", self.access_token, method, url, data)
        headers = {'Authorization': f'Bearer {self.access_token}', 'Content-Type': 'application/json'}
        async with aiohttp.ClientSession() as session:
            async with session.request(method, url, headers=headers, data=data) as response:
                return {'status_code': response.status, 'data': await response.json()}









# --------------------------------- game.js -----------------------

import { navigateTo } from "../../utils/navTo.js";
import { userDetailUrl, GamePlaySocketUrl } from "../../constants/constants.js";

export let ws;

export async function fetchGame() {
    const canvas = document.getElementById("canvas-pong");
const ctx = canvas.getContext("2d");
const game_id = localStorage.getItem("game_id");
localStorage.removeItem("game_id");

const response = await fetch(userDetailUrl, {
    method: "GET",
    headers: {
        "Content-Type": "application/json",
        "Authorization": `Bearer ${localStorage.getItem("access_token")}`,
}
});
if (!response.ok) {
const errorData = await response.json();
if (response.status === 401) {
if (errorData.error === "Token has expired") {
await RefreshToken();
return fetchGame();
}
document.getElementById("logout-button").click();
return;
}
if (response.status === 500) {
let message = "error: " + errorData.error;
alert(message);
navigateTo("/");
return;
}
throw new Error(errorData.error);
}


if (!game_id)
{
navigateTo("/");
return;
}

var connection = GamePlaySocketUrl + "?room=" + game_id + "?token=" + localStorage.getItem("access_token");
ws = new WebSocket(connection);



ws.onopen = () => {
console.log("Connected to server");
}

function drawPaddles(paddLeft, paddRight, paddLeftUsername, paddRightUsername) {
ctx.fillStyle = "white";

// Sol paddle'ı çiz
ctx.fillRect(paddLeft.positionX, paddLeft.positionY, paddLeft.sizeX, paddLeft.sizeY);

// Sağ paddle'ı çiz
ctx.fillRect(paddRight.positionX, paddRight.positionY, paddRight.sizeX, paddRight.sizeY);

ctx.font = '30px Arial';
ctx.textAlign = 'center';

// Sol taraf skoru ve kullanıcı adı
ctx.fillText(paddLeft.score, canvas.width * 0.25, 50);
ctx.fillText(paddLeftUsername, canvas.width * 0.25, 90);

// Sağ taraf skoru ve kullanıcı adı
ctx.fillText(paddRight.score, canvas.width * 0.75, 50);
ctx.fillText(paddRightUsername, canvas.width * 0.75, 90);
}

function drawBall(ball) {
ctx.beginPath();
ctx.arc(ball.positionX, ball.positionY, ball.size, 0, Math.PI * 2);
ctx.fillStyle = "white";
ctx.fill();
ctx.closePath();
}

ws.onmessage = (message) => {
let items = JSON.parse(message.data);

console.log("-----> " + items.message);
if (items.message === "game_over") {
console.log("Game Over");
console.log("Winner: " + items.winner);
ctx.font = '30px Arial';
ctx.fillText("Game Over", canvas.width / 2 - 100, canvas.height / 2);
var winner = "Player " + items.winner + " wins!";
ctx.fillText(winner, canvas.width / 2 - 100, canvas.height / 2 + 50);
if (items.newGame)
{
localStorage.setItem("game_id", items.newGame);
navigateTo("/game");
}
return;
} else if (items.message === "game_run") {
ctx.clearRect(0, 0, canvas.width, canvas.height);
drawPaddles(items.padd_left, items.padd_right, items.padd_left_username, items.padd_right_username);
drawBall(items.ball);
}
}

ws.onclose = () => {
    console.log("Disconnected from server");
}

ws.onerror = () => {
    console.error("Error connecting to server");
}

document.addEventListener("keydown", function (event) {
if (event.key === "w" || event.key === "s") {
ws.send(keys[event.keyCode]);
}
});

const keys = {
    87: "w",
    83: "s",
};

}
